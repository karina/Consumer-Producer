Karina Ruzinov and Devon Peticolas
Readme

	Our book order project was implemented using multithreading, mutex's and semaphores. To make the multiple producers we multithreaded in our main using an array of producer threads to be able to generate them in a loop. Our producerfunction is supposed to generate the orders and enqueue them for the consumer to later use. Our generate order function is very unique where we have 15 different verbs,nouns, and adjectives which are randomly generated to create unique and funny titles. We also randomly generate the price of the books and we assign each order a customer ID. This order gets passed into our producer function which mutex's the queue and then enqueue's the order. Each thread does this in a loop until a flag is set by SIGUSR2 to break out of the loop. 
	When the SIGUSR1 signal is raised, our signal handler catches it and calls our consumer function. The consumer function is originally waiting for the semaphore to post in the signal handler. Our consumer function mutex locks the queue and dequeues everything, which concurrently frees the nodes in the queue and then later frees the order object. Before it frees the order object it prints out the timestamp and everything involving the order. Since it was not specified in the assignment, we let whatever the thread that the program was currently in finish and then it breaks out of it for thread safety. The main function then frees everything and safely quits our code.
	For our database, we had 100 randomly generated names, addresses and credit limits which were all in a file called "database." We pass in our database as the third parameter to our main function and then read it into a pointer to a struct called DatabaseEntry which makes and array based on customer ID of all of the customers which makes all of them easily accessible from our consumer function to check the credit limit and to print out the shipping address.
